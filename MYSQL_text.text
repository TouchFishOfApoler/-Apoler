1.查找当前用户有权访问的所有数据库
 show databases;
2.查找当前用户连接到了哪个数据库
select database();
3.获知当前的数据目录
show variables like 'datadir';
4.断开连接
ctrl+D 或 exit;
5.列出所有存储引擎
show engines\g    ps:与列定义一起，还应该指定存储引擎。在所有引擎中，InnoDB是唯一的事务引擎，也是默认引擎
6.列出所有表
show tables;
7.查看表结构
show create table 表名\g
或 desc 表名;
8.克隆表结构
create table 新表表名 like 旧表表名;
9.有下划线“_”或点“.”时，要用反引号包起来。
    反引号:“ ` ”  引号:“ ' ”
10.ERROR 1366 (HY000): Incorrect string value: '\xE5\xBC\xA0' for column 'first_name' at row 1   报错原因：
这个表内的一些列名编码方式不是utf8，使用指令 “alter table 表名 change 表内列名 表内列名 定义类型 character set utf8;”改成utf8编码方式即可。
PS：
1.查看MySQL字符集的编码方式，使用代码：show variables like '%char%';
2.查看当前数据库字符集的编码方式，使用代码：show create database 数据库名;
3.查看所使用表字符集的编码方式，使用代码：show create table 表名;

11.列定义时，定义为主键的列，不能为空，没有定义默认的列，默认可以为空。如果主键还有 auto_increment，也就是自动生成线性递增序列。
12.insert语句中的 ignore作用
在用insert执行插入数据到表中时用到，放在insert 和 into之间。如果插入的数据中的某一行，与原表中某行一样，则在插入时被忽略，insert语句仍会执行成功，并会给一条警告和重复数据的数目。如果没有ignore则会报错。
13.updata更新表中的记录
update 表名 set 列名='',列名='' where 列名='';
PS:
where：这是用于过滤的子句。在where子句后指定的任何条件都会用于过滤，被筛选出来的行都会被更新。
如果不用where子句进行过滤筛选，则会将表中的所有行都更新一次。
14.delete删除
delete from 表名 where 列名='' and 列名='';
如果不用where子句进行过滤筛选，则会将表中所有行都删除掉。

PS：where子句可以配合and或or使用，and是满足两个或两个以上条件的列名，or是只要是这其中的任何一个条件满足都会被筛选中。

15.在很多情况下，我们需要处理重复项，重复的定义由主键标识决定，因为行的唯一性是由主键标识所决定的。
1、replace 如果存在，则会简单地删除行并插入新行。如果行不存在，则replace相当于insert，会插入一个新行。
2、如果想更新重复项，而又不想出现创建新行的情况，则用insert搭配on duplicate key update 列名='',列名='';比如update payment=payment+values(payment);意思就是将新输入的更新项中的payment属性值(也就是values(payment))加上表中原本的payment值。

16.删除表的所有行，保留表结构的最快方法是使用truncate table。且其是Mysql中的DDL操作，也就是说一旦数据被清空，就不能被回滚。


查询操作：

in,检查一个值是否在一组值中。
between....and,检查一个值是否在一个范围内。
not,可以使用not运算符简单的来否定结果。 


1.select * from 表名;星号(*)代表表中的所有列，输出表中的所有列。

2.select emp_no,dept_no from dept_manager;意思是将dept_manager表中的emp_no和dept_no列选择 并输出。

3.select count(*) from employees;意思是查询employees表中有多少行。

4.select emp_no from employees where first_name='Georgi' and last_name='Facello';意思是查询employees表中first_name为Georgi且last_name为Facello的人的emp_no。

5.select count(*) from employees where last_name in ('Christ','Lamba','Baba');意思就是找出last_name为'Christ'或'Lamba'或'Baba'的所有人的人数。

6.select count(*) from employees where hire_date between '1986-12-01'and'1986-12-31';意思是找出hire_date的值在1986年12月1日至1986年12月31日之间的人数。

7.select count(*) from employees where hire_date not between '1986-12-01'and'1986-12-31';意思是找出hire_date的值不是在1986年12月1日至1986年12月31日之间的人数。


like运算符可以实现简单地模式匹配。下划线(_)来精准的匹配一个字符，百分号(%)来匹配任意数量的字符。


8.select count(*) from employees where first_name like 'christ%';找出以christ开头的所有人的人数。

9.select count(*) from employees where first_name like 'christ%ed';找出名字以christ开头并以ed结尾的所有人的人数。

10.select count(*) from employees where first_name like '%sri%';找出名字中包含sri的所有人的人数。

11.select count(*) from employees where first_name like '%er';找出名字中以er结尾的所有人的人数。

12.select count(*) from employees where first_name like '__ka%';找出名字中以任意2个字符开头，后面跟随ka，再后面跟随任意数量字符的所有人的人数。



利用rlike或regexp运算符即可在where过滤字句中使用正则表达式。

1.SELECT COUNT(*) FROM `employees` WHERE first_name RLIKE '^christ';找出名字以christ开头的所有人的人数。

2.SELECT COUNT(*) FROM `employees` WHERE last_name RLIKE 'ba$';找出姓氏以ba结尾的所有人的人数。

3.SELECT COUNT(*) FROM `employees` WHERE last_name not RLIKE '[aeiou]';查找姓氏不包含(a、e、i、o、u)的所有人的人数。

4.SELECT first_name,last_name FROM `employees` WHERE hire_date < '1986-01-01' LIMIT 0,10;查找1986年之前的前10位人的姓和名。

limit是mysql的内置函数，一般都用于限制查询结果的条数

limit子句可以用于强制select语句返回指定的记录数，limit接受一个或两个‘数字’的参数，参数必须是一个整数常量。

比如：给定出两个参数，第一个参数指定的是返回记录行的偏移量，
                      第二个参数指定的是返回记录行的最大数目
语法如下：LIMIT [位置偏移量，行数]

如：limit 1,10 意思就是从2开始显示10位。也可以只输1个数字，如：limit 10 意思就是显示前10位。

5.SELECT COUNT(*) AS nums FROM `employees` WHERE hire_date < '1986-01-01';
表别名，一般情况下，使用count(*)得出的统计数值，显示位COUNT(*)。使用 as别名进行更改。


《对结果排序》

order by跟desc和asc结合使用，来指定结果的排序，desc是降序，asc是升序，默认是升序进行。
列如：order by 列名 desc/asc
也可以不指定列名，改用数字，如： order by 2 desc/asc 对第二列的列进行降序/升序 排序。
还可以结合limit子句来指定返回的记录数。


 select emp_no,salary from salaries order by salary desc limit 5;意思为查找薪水最高的前5名员工的员工编号。
详解：因为order by salary desc是指定salary列进行降序，从大到小的排序，limit 5就是在这从大到小的排序中指定返回前5个记录数。



《对结果进行分组》

group by 列名 将这个列名里的所有内容进行分组。

select gender,count(*) from employees group by gender;理解：'from employees group by gender'先将表employees里的gender列里的所有内容进行分组，然后'select gender,count(*)'意思就是将这些分的组的内容和其相应数量选择出来。

《与order by、limit结合》

select first_name,count(first_name) as count from employees group by first_name order by count desc limit 10;
详解：'from employees group by first_name'将employees表内的first_name列进行分组。
'select first_name,count(first_name) as count'就是将之前group by子句分的组的内容和其相应数量选择出来。
'order by count desc limit 10'意思就是将之前count(first_name)选择出来的分组的数量和就像降序，再用limit 10 将最大的前10个选择出来。


《year('1980-06-12'); 取出年份。》

select year(from_date),sum(salary) from salaries group by year(from_date) order by sum(salary) desc limit 10;详解:
'from salaries group by year(from_date)'将salaries表中的year(from_date)进行分组，也就是将年份一样的归为一组，进行分组。
'select year(from_date),sum(salary)'将分的组的年份和'和'选择出来。
'order by sum(salary) desc limit 10'将各个组的'和'进行降序排序，然后指定前10个选择出来。



《avg  ：求平均值》

select emp_no,avg(salary) from salaries group by emp_no order by avg(salary) desc limit 10;
详解：
'from salaries group by emp_no'将salaries表中的emp_no进行分组，也就是将emp_no一样的归为一组，进行分组。
'select emp_no,avg(salary)'将分的组的emp_no和 组中的各元素的salary的平均值求出来。
'order by avg(salary) desc limit 10'将各个组的平均值进行降序排序，然后指定前10个选择出来。


《distinct  ：过滤出表中的不同的条目。》

select distinct title from titles;
详解：将titles表中的title列，中的不同的条目筛选出来。就是有多条重复的，只显示一个。


《having  ：可以过滤group by子句的结果的子句》

select emp_no,avg(salary) from salaries group by emp_no having avg(salary) >140000 order by avg(salary) desc;
详解：
'from salaries group by emp_no'根据salaries表中的emp_no列进行分组，emp_no一样的分成一组。
'select emp_no,avg(salary)'将分的组的emp_no和avg(salary)选择。
'having avg(salary) >140000'将各个组的avg(salary)大于140000的选择出来。
'order by avg(salary) desc'将最后选出的组，按照avg(salary)的值进行降序排序。



《拼接字段》
与其他DBMS用+或||来实现拼接不一样，MySQL使用concat()函数来实现拼接字段。

《Concat()使用方法》
Concat()函数拼接串，各个串之间需要用逗号分隔开。
例：select concat(trim(dept_name),' (',trim(dept_no),')') from departments;
其中Concat()中包含4个串：“dept_name” 、 “' ('” 、 “dept_no” 、 “')'”。

《trim()函数》
Trim()函数作用是去掉串左右两边的空格。
RTrim()去掉串右边的空格。
LTrim()去掉串左边的空格。


《使用别名》
如果只是用select语句拼接地址字段，但此新计算列实际上时没有名字的，是没有办法被客户机引用的。解决办法是，使用关键字AS赋予别名即可。


《算术计算》
例：select concat(trim(year(from_date)),'-',trim(year(to_date)))as 年份,salary as 年工资 from salaries where emp_no=10001 order by 年份;



《函数》

《文本处理函数》
常用函数：
left(列名,数值（从左边开始返回几个）)   返回串左边的字符
right(列名,数值（从右边开始返回几个）)  返回串右边的字符
LTrim(列名)                             去掉串左边的字符
RTrim(列名)                             去掉串右边的字符
Lower(列名)                             将串转换为小写
Upper(列名)                             将串转换为大写
Length(列名)                            返回串的长度
Soundex(列名或字符)                     返回串的soundex值
SubString()                             返回子串的字符
Locate()                                找出串的一个子串


《日期和时间处理函数》
常用函数：
date(列名或串)                          提取串中的日期
time(列名或串)                          提取串中的时间值
curdate()                               返回当前日期
curtime()                               返回当前时间
now()                                   返回当前日期和时间
year()                                  返回一个日期的年份部分
month()                                 返回一个日期的月份部分
day()                                   返回一个日期的天数部分
hour()                                  返回一个时间的小时部分
minute()                                返回一个时间的分钟部分
second()                                返回一个时间的秒部分
dayofweek()                             对于一个日期，返回对应的星期几


《数值处理函数》

 
abs()                                   返回一个数的绝对值
cos()                                   返回一个角度的余旋
exp()                                   返回一个数的指数值
mod()                                   返回除操作的余数
pi()                                    返回圆周率
rand()                                  返回一个随机数
sin()                                   返回一个角度的正旋
sqrt()                                  返回一个数的平方根
tan()                                   返回一个角度的正切


《聚集函数》
需要汇总数据，而不用把它们实际检索出来。需要的是表中的数据汇总，而不是数据本身，所以MYSQL提供了5个聚集函数。

avg()                                   返回某列的平均值
count()                                 返回某列的行数
sum()                                   返回某列值之和
max()                                   返回某列的最大值
min()                                   返回某列的最小值



注意：avg() 函数忽略列值为null的行，如列值为:1、2、null、4，的平均值为=(1+2+4)/3=2.333。


count(*) 对表中行的数目进行计数，不管列表中包含的是空值(NULL)还是非空值。
count(column)忽略NULL值。如：count(列名)，如若指定了列名，则指定列的值为空的行会被count()函数忽略。

sum(列名)、max(列名)、min(列名) 都忽略值为NULL的行。

聚集函数可以配合 distinct、all。
distinct    只包含不同的值
all         对所有的行执行计算，可以指定all参数或不给参数，因为all是默认参数。

例子： select count(distinct emp_no) from salaries;


《group by分组子句》
注意：group by子句必须出现在where子句之后，order by子句之前。


《过滤分组的子句:having》
注意:where只能过滤行，没有分组的概念。而having可以过滤分组，并且事实上，where子句实现的过滤都可以使用having来代替，where和having的句法是相同的，只是关键字有差别。

还有一个重要区别是，where是在分组前进行过滤，而having是在数据分组后进行过滤的。

例子： select emp_no,sum(salary) from salaries where emp_no<10005 group by emp_no having sum(salary) <1000000;



《子查询》
例子：
select emp_no,sum(salary) from salaries group by emp_no having emp_no = (select emp_no from salaries group by emp_no order by sum(salary) desc limit 1);


《联结》

《等值联结》
  
《内部联结》
关键字： from 表名 inner join 表名 on 联结条件

《自联结》
通过给同一个表设置不同的别名 来实现自联结。通常用来替代子查询，因为有时自联结处理速度比子查询快得多。

《自然联结》
什么是自然联结？自然联结就是排除多次出现，使每个列只返回一次。
怎么样完成自然联结呐？系统不完成，由自己完成。一般通过使用通配符(select *)，对其他表的列使用明确的子集来完成。

《外部联结》

关键字：from 表名 left/right 表名 on 联结条件

细看：https://blog.csdn.net/pinkfriday/article/details/79038381
讲的相当nice！关于笛卡尔积、内部联结、自然联结和外部联结 讲的很通透！



《《组合查询》》

《使用union》

规则：1、union必须由两条或两条以上的select语句组成，语句之间用关键字union分隔。(如：如果需要组合4条select语句，将需要使用3个union关键字)
      2、union中的每个select查询中都必须包含相同的列、表达式或聚集函数。(不过各个列不需要以相同的次序列出)
      3、如果用union(并)组合查询select语句，则会将重复的行自动取消。如果不想取消重复的行则需使用 union all。

排序：如果向对用union(并)组合的查询select语句， 使用order by子句来排序，不必每个select语句的后边都使用order by，这是错误的，只需要在最后一条select语句之后用order by 排序即可对整个union(并)组合的查询select语句排序。


#测试
